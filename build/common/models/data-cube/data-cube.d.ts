/// <reference types="q" />
import * as Q from 'q';
import { List, OrderedSet } from 'immutable';
import { Instance } from 'immutable-class';
import { Duration, Timezone } from 'chronoshift';
import { Expression, ExpressionJS, Executor, External, RefExpression, Dataset, Attributes, AttributeJSs, SortAction, DatasetFullType, CustomDruidAggregations, CustomDruidTransforms } from 'plywood';
import { Dimension, DimensionJS } from '../dimension/dimension';
import { Measure, MeasureJS } from '../measure/measure';
import { Filter, FilterJS } from '../filter/filter';
import { Splits, SplitsJS } from '../splits/splits';
import { RefreshRule, RefreshRuleJS } from '../refresh-rule/refresh-rule';
import { Cluster } from '../cluster/cluster';
import { Timekeeper } from "../timekeeper/timekeeper";
export declare type Introspection = 'none' | 'no-autofill' | 'autofill-dimensions-only' | 'autofill-measures-only' | 'autofill-all';
export interface DataCubeValue {
    name: string;
    title?: string;
    description?: string;
    clusterName: string;
    source: string;
    group?: string;
    subsetFormula?: string;
    rollup?: boolean;
    options?: DataCubeOptions;
    introspection?: Introspection;
    attributeOverrides?: Attributes;
    attributes?: Attributes;
    derivedAttributes?: Lookup<Expression>;
    dimensions?: List<Dimension>;
    measures?: List<Measure>;
    timeAttribute?: RefExpression;
    defaultTimezone?: Timezone;
    defaultFilter?: Filter;
    defaultSplits?: Splits;
    defaultDuration?: Duration;
    defaultSortMeasure?: string;
    defaultSelectedMeasures?: OrderedSet<string>;
    defaultPinnedDimensions?: OrderedSet<string>;
    refreshRule?: RefreshRule;
    cluster?: Cluster;
    executor?: Executor;
}
export interface DataCubeJS {
    name: string;
    title?: string;
    description?: string;
    clusterName: string;
    source: string;
    group?: string;
    subsetFormula?: string;
    rollup?: boolean;
    options?: DataCubeOptions;
    introspection?: Introspection;
    attributeOverrides?: AttributeJSs;
    attributes?: AttributeJSs;
    derivedAttributes?: Lookup<ExpressionJS>;
    dimensions?: DimensionJS[];
    measures?: MeasureJS[];
    timeAttribute?: string;
    defaultTimezone?: string;
    defaultFilter?: FilterJS;
    defaultSplits?: SplitsJS;
    defaultDuration?: string;
    defaultSortMeasure?: string;
    defaultSelectedMeasures?: string[];
    defaultPinnedDimensions?: string[];
    refreshRule?: RefreshRuleJS;
    longForm?: LongForm;
}
export interface DataCubeOptions {
    customAggregations?: CustomDruidAggregations;
    customTransforms?: CustomDruidTransforms;
    druidContext?: Lookup<any>;
    priority?: number;
    defaultSplits?: SplitsJS;
    defaultSplitDimension?: string;
    skipIntrospection?: boolean;
    disableAutofill?: boolean;
    attributeOverrides?: AttributeJSs;
    [thing: string]: any;
}
export interface DataCubeContext {
    cluster?: Cluster;
    executor?: Executor;
}
export interface LongForm {
    metricColumn: string;
    possibleAggregates: Lookup<any>;
    addSubsetFilter?: boolean;
    measures: Array<MeasureJS | LongFormMeasure>;
}
export interface LongFormMeasure {
    aggregate: string;
    value: string;
    title: string;
    units?: string;
}
export declare class DataCube implements Instance<DataCubeValue, DataCubeJS> {
    static DEFAULT_INTROSPECTION: Introspection;
    static INTROSPECTION_VALUES: Introspection[];
    static DEFAULT_DEFAULT_TIMEZONE: Timezone;
    static DEFAULT_DEFAULT_FILTER: Filter;
    static DEFAULT_DEFAULT_SPLITS: Splits;
    static DEFAULT_DEFAULT_DURATION: Duration;
    static isDataCube(candidate: any): candidate is DataCube;
    static queryMaxTime(dataCube: DataCube): Q.Promise<Date>;
    static fromClusterAndExternal(name: string, cluster: Cluster, external: External): DataCube;
    static fromJS(parameters: DataCubeJS, context?: DataCubeContext): DataCube;
    name: string;
    title: string;
    description: string;
    clusterName: string;
    source: string;
    group: string;
    subsetFormula: string;
    subsetExpression: Expression;
    rollup: boolean;
    options: DataCubeOptions;
    introspection: Introspection;
    attributes: Attributes;
    attributeOverrides: Attributes;
    derivedAttributes: Lookup<Expression>;
    dimensions: List<Dimension>;
    measures: List<Measure>;
    timeAttribute: RefExpression;
    defaultTimezone: Timezone;
    defaultFilter: Filter;
    defaultSplits: Splits;
    defaultDuration: Duration;
    defaultSortMeasure: string;
    defaultSelectedMeasures: OrderedSet<string>;
    defaultPinnedDimensions: OrderedSet<string>;
    refreshRule: RefreshRule;
    cluster: Cluster;
    executor: Executor;
    constructor(parameters: DataCubeValue);
    valueOf(): DataCubeValue;
    toJS(): DataCubeJS;
    toJSON(): DataCubeJS;
    toString(): string;
    equals(other: DataCube): boolean;
    private _validateDefaults();
    toExternal(): External;
    getMainTypeContext(): DatasetFullType;
    getIssues(): string[];
    updateCluster(cluster: Cluster): DataCube;
    updateWithDataset(dataset: Dataset): DataCube;
    updateWithExternal(external: External): DataCube;
    attachExecutor(executor: Executor): DataCube;
    toClientDataCube(): DataCube;
    isQueryable(): boolean;
    getMaxTime(timekeeper: Timekeeper): Date;
    updatedText(timekeeper: Timekeeper, timezone: Timezone): string;
    getDimension(dimensionName: string): Dimension;
    getDimensionByExpression(expression: Expression): Dimension;
    getDimensionByKind(kind: string): List<Dimension>;
    getTimeDimension(): Dimension;
    isTimeAttribute(ex: Expression): boolean;
    getMeasure(measureName: string): Measure;
    getMeasureByExpression(expression: Expression): Measure;
    changeDimensions(dimensions: List<Dimension>): DataCube;
    rolledUp(): boolean;
    deduceAttributes(): Attributes;
    addAttributes(newAttributes: Attributes): DataCube;
    getIntrospection(): Introspection;
    getDefaultTimezone(): Timezone;
    getDefaultFilter(): Filter;
    getDefaultSplits(): Splits;
    getDefaultDuration(): Duration;
    getDefaultSortMeasure(): string;
    getDefaultSelectedMeasures(): OrderedSet<string>;
    getDefaultPinnedDimensions(): OrderedSet<string>;
    change(propertyName: string, newValue: any): DataCube;
    changeDefaultSortMeasure(defaultSortMeasure: string): DataCube;
    changeTitle(title: string): DataCube;
    changeDescription(description: string): DataCube;
    changeMeasures(measures: List<Measure>): DataCube;
    getDefaultSortAction(): SortAction;
    sameGroup(otherDataCube: DataCube): boolean;
}
