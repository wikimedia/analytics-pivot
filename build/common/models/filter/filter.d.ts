import { List } from 'immutable';
import { Instance } from 'immutable-class';
import { Timezone, Duration } from 'chronoshift';
import { Expression, ExpressionJS, Set, Range } from 'plywood';
import { Dimension } from '../dimension/dimension';
import { FilterClause, FilterSelection } from '../filter-clause/filter-clause';
export declare type FilterMode = 'exclude' | 'include' | 'regex' | 'contains';
export declare type FilterValue = List<FilterClause>;
export declare type FilterJS = ExpressionJS | string;
export declare class Filter implements Instance<FilterValue, FilterJS> {
    static EMPTY: Filter;
    static EXCLUDED: FilterMode;
    static INCLUDED: FilterMode;
    static REGEX: FilterMode;
    static CONTAINS: FilterMode;
    static isFilter(candidate: any): candidate is Filter;
    static fromClause(clause: FilterClause): Filter;
    static fromJS(parameters: FilterJS): Filter;
    clauses: List<FilterClause>;
    constructor(parameters: FilterValue);
    valueOf(): FilterValue;
    toJS(): FilterJS;
    toJSON(): FilterJS;
    toString(): string;
    equals(other: Filter): boolean;
    replaceByIndex(index: number, replace: FilterClause): Filter;
    insertByIndex(index: number, insert: FilterClause): Filter;
    empty(): boolean;
    single(): boolean;
    length(): number;
    toExpression(): Expression;
    isEmpty(): boolean;
    isRelative(): boolean;
    getSpecificFilter(now: Date, maxTime: Date, timezone: Timezone): Filter;
    private indexOfClause(attribute);
    clauseForExpression(attribute: Expression): FilterClause;
    filteredOn(attribute: Expression): boolean;
    filteredOnValue(attribute: Expression, value: any): boolean;
    addValue(attribute: Expression, value: any): Filter;
    remove(attribute: Expression): Filter;
    removeValue(attribute: Expression, value: any): Filter;
    toggleValue(attribute: Expression, value: any): Filter;
    getSelection(attribute: Expression): FilterSelection;
    setSelection(attribute: Expression, selection: Expression): Filter;
    getExtent(attribute: Expression): Range<any>;
    getFileString(timeAttribute: Expression): string;
    getLiteralSet(attribute: Expression): Set;
    getClausesForDimension(dimension: Dimension): List<FilterClause>;
    getModeForDimension(dimension: Dimension): FilterMode;
    setClause(expression: FilterClause): Filter;
    applyDelta(delta: Filter): Filter;
    getSingleClauseSet(): Set;
    constrainToDimensions(dimensions: List<Dimension>, timeAttribute: Expression, oldTimeAttribute?: Expression): Filter;
    getDifferentAttributes(other: Filter): Expression[];
    overQuery(duration: Duration, timezone: Timezone, timeAttribute: Expression): Filter;
    setExclusionforDimension(exclusion: boolean, dimension: Dimension): Filter;
}
